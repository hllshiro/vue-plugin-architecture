# 架构总览

本系统是一个基于插件化的前端微核（Micro-core）架构，旨在提供一个可扩展的动态布局和功能组合平台。其核心思想是将应用的核心能力（如布局管理、事件通信、数据服务）与业务功能（作为“插件”实现）完全解耦。

## 设计目标

- **高度可扩展性**: 任何业务功能都可以作为独立的插件进行开发、部署和加载。
- **关注点分离**: 核心框架专注于提供稳定、通用的服务，而插件则专注于实现具体的业务逻辑。
- **动态化**: 支持在运行时通过URL动态加载、卸载和更新插件，无需重新编译主应用。
- **开发效率**: 插件可以独立开发和测试，简化了团队协作和维护流程。

## 核心模块

项目采用Monorepo结构，主要由以下几个核心模块（Package）组成：

### 1. `@vue-plugin-arch/core`

核心运行时库，是整个架构的心脏。它不关心任何具体的业务逻辑，只提供一套完整的插件生命周期管理和基础服务，包括：

- **插件管理器 (`PluginManager`)**: 负责插件的加载、初始化、激活和卸载。
- **布局管理器 (`LayoutManager`)**: 提供动态渲染能力，允许插件将自己的Vue组件注册到应用的指定位置（如侧边栏、主内容区等）。
- **事件总线 (`EventBus`)**: 提供一个发布/订阅模式的通信机制，用于在插件之间或插件与主应用之间传递消息，实现模块解耦。
- **数据服务 (`PluginDataService`)**: 提供一个统一的键值存储API，允许插件持久化或共享状态，同时通过命名空间进行隔离。
- **API代理 (`PluginServiceProxy`)**: 一个安全代理，将核心服务（布局、事件、数据）以受控的方式暴露给每个插件，避免插件直接访问核心实例。

### 2. `@vue-plugin-arch/vite-plugin`

一个为本架构定制的Vite构建插件。它的主要职责是在**构建时**而非运行时工作：

- **插件注册表服务**: 提供 HTTP 请求拦截，合并本地插件和远程插件清单。
- **本地插件扫描**: 自动扫描项目 `packages/plugins` 目录下的所有插件包，生成 `/@fs/` URL用于开发模式。
- **importMap注入**: 在构建模式下，自动注入importMap到HTML中，以支持外部依赖的模块解析。
- **热更新支持**: 在开发模式下，监听插件文件的变化，并自动更新插件注册表，实现无缝的开发体验。

### 3. `@vue-plugin-arch/types`

提供整个项目中共享的TypeScript类型定义。通过统一的类型，确保了核心库、插件和主应用之间接口调用的类型安全。

### 4. `plugins/*`

所有业务功能插件的存放目录。每个插件都是一个独立的包，拥有自己的 `package.json`。插件通过其入口文件（通常是 `src/index.ts`）导出一个符合规范的插件定义对象。

### 5. `demo`

一个示例性的主应用，用于演示如何集成和使用上述所有模块。它展示了如何初始化`core`库、加载插件以及与插件进行交互。

## 架构图

```mermaid
graph TD
    subgraph "开发/构建阶段"
        A[开发者] --> B("插件源代码<br/>packages/plugins/*");
        C("Vite Dev/Build") --> D["@vue-plugin-arch/vite-plugin"];
        B --> D;
        D -- 扫描本地插件 --> E["/@fs/ URLs<br/>(开发模式)"];
        D -- 注入importMap --> F["HTML + importMap<br/>(构建模式)"];
        D -- 提供端点 --> G["/api/plugin-registry.json"];
    end

    subgraph "运行时 (浏览器)"
        H("主应用 Demo") -- fetch --> G;
        G -- 返回 --> I["插件注册表<br/>(本地+远程)"];
        H -- 初始化 --> J["@vue-plugin-arch/core"];
        I --> K{PluginManager};
        K -- "import(pluginUrl)" --> L("动态加载插件模块");
        L -- 安装 --> M[插件实例];
        M -- 调用API --> J;
    end

    subgraph "模块解析"
        N["importMap<br/>(构建模式)"] --> L;
        O["/@fs/ URLs<br/>(开发模式)"] --> L;
    end

    A -- 编写 --> H;
    C -- 打包 --> H;
    E --> O;
    F --> N;
```

## 工作流程

工作流程根据环境分为**开发/构建时**和**运行时**两个主要阶段。

### 开发模式 (Dev Mode)

1.  **启动**: 开发者运行 `pnpm dev` 启动主应用（`demo`）。
2.  **插件注册表服务**: Vite启动时，`@vue-plugin-arch/vite-plugin` 被激活，提供 `/api/plugin-registry.json` 端点服务。
3.  **本地插件扫描**: 插件自动扫描 `packages/plugins` 目录，为每个本地插件生成 `/@fs/` URL，指向其构建产物。
4.  **远程插件合并**: 读取静态注册表文件（如果存在），将远程插件与本地插件合并，本地插件优先。
5.  **动态加载**: 主应用通过fetch获取插件注册表，然后使用 `import()` 和插件的URL动态加载插件模块。
6.  **热更新**: 当插件文件发生变化时，注册表自动更新，支持插件的热重载。

### 构建模式 (Build Mode)

1.  **启动**: 开发者运行 `pnpm build` 对主应用进行生产环境打包。
2.  **importMap注入**: `@vue-plugin-arch/vite-plugin` 在HTML中注入importMap，配置外部依赖的模块路径映射。
3.  **静态资源复制**: 将外部依赖（如vue.js）复制到构建输出目录，支持运行时的模块解析。
4.  **插件注册表**: 生成静态的插件注册表文件，包含所有可用插件的URL和元数据。
5.  **产出**: 最终生成包含importMap的HTML文件和静态插件注册表，支持运行时动态加载预构建的插件。

### 运行时 (浏览器)

此阶段在开发和构建模式下基本相同，但模块解析机制不同。

1.  **应用初始化**: 浏览器加载主应用，`demo` 应用启动并初始化 `@vue-plugin-arch/core` 中的 `PluginManager`。
2.  **获取插件注册表**: 主应用通过fetch请求 `/api/plugin-registry.json` 获取可用插件列表。
3.  **模块解析**:

- **开发模式**: 使用 `/@fs/` URL直接加载本地插件构建产物
- **构建模式**: 通过importMap解析外部依赖，支持CDN或其他远程URL加载插件

4.  **按需加载插件**: 当需要加载某个插件时，`PluginManager` 使用插件清单中的URL通过 `import()` 动态加载。
5.  **安装插件**: 代码加载成功后，`PluginManager` 执行插件的 `install` 方法，并将封装后的API代理 (`proxy`) 注入插件。
6.  **插件激活**: 插件在其 `install` 方法中，调用API（如 `proxy.layoutApi.registerComponent`）来注册自己的UI组件、监听事件或执行其他初始化任务，正式开始工作。
